import * as fs from 'fs';
import * as path from 'path';
import { EnvSchema, Variable } from '../types/index.js';

/**
 * Convert schema type to TypeScript type
 */
function toTypeScriptType(spec: Variable): string {
  // If enum is defined, use literal union
  if (spec.enum && spec.enum.length > 0) {
    return spec.enum.map((v) => `'${v}'`).join(' | ');
  }

  switch (spec.type) {
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'string':
    default:
      return 'string';
  }
}

/**
 * Generate ProcessEnv interface (always strings)
 */
function generateProcessEnvInterface(schema: EnvSchema): string {
  const lines: string[] = [];
  lines.push('  interface ProcessEnv {');

  for (const [name, spec] of Object.entries(schema.variables)) {
    const comment = spec.description ? `    /** ${spec.description} */\n` : '';

    // ProcessEnv values are always string | undefined
    if (spec.enum && spec.enum.length > 0) {
      const enumType = spec.enum.map((v) => `'${v}'`).join(' | ');
      const optional = spec.required ? '' : '?';
      lines.push(`${comment}    ${name}${optional}: ${enumType};`);
    } else {
      const optional = spec.required ? '' : '?';
      lines.push(`${comment}    ${name}${optional}: string;`);
    }
  }

  lines.push('  }');
  return lines.join('\n');
}

/**
 * Generate typed Env interface (with proper types)
 */
function generateEnvInterface(schema: EnvSchema): string {
  const lines: string[] = [];
  lines.push('export interface Env {');

  for (const [name, spec] of Object.entries(schema.variables)) {
    const comment = spec.description ? `  /** ${spec.description} */\n` : '';
    const tsType = toTypeScriptType(spec);
    const optional = spec.required && spec.default === undefined ? '' : '?';

    lines.push(`${comment}  ${name}${optional}: ${tsType};`);
  }

  lines.push('}');
  return lines.join('\n');
}

/**
 * Generate TypeScript declarations from schema
 */
export function generateTypeScript(
  schema: EnvSchema,
  options: { namespace?: boolean } = {}
): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by env-guardian. Do not edit manually.');
  lines.push('// Regenerate with: npx env-guardian generate');
  lines.push('');

  if (options.namespace !== false) {
    // Generate ProcessEnv augmentation
    lines.push('declare global {');
    lines.push('  namespace NodeJS {');
    lines.push(generateProcessEnvInterface(schema));
    lines.push('  }');
    lines.push('}');
    lines.push('');
  }

  // Generate typed Env interface
  lines.push(generateEnvInterface(schema));
  lines.push('');

  // Generate helper type for required env vars
  const requiredVars = Object.entries(schema.variables)
    .filter(([_, spec]) => spec.required && spec.default === undefined)
    .map(([name]) => `'${name}'`);

  if (requiredVars.length > 0) {
    lines.push(`export type RequiredEnvVars = ${requiredVars.join(' | ')};`);
  } else {
    lines.push('export type RequiredEnvVars = never;');
  }
  lines.push('');

  // Generate helper type for optional env vars
  const optionalVars = Object.entries(schema.variables)
    .filter(([_, spec]) => !spec.required || spec.default !== undefined)
    .map(([name]) => `'${name}'`);

  if (optionalVars.length > 0) {
    lines.push(`export type OptionalEnvVars = ${optionalVars.join(' | ')};`);
  } else {
    lines.push('export type OptionalEnvVars = never;');
  }
  lines.push('');

  // Export empty object to make this a module
  lines.push('export {};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Write TypeScript declarations to file
 */
export function writeTypeScriptFile(
  schema: EnvSchema,
  outputPath: string,
  options: { namespace?: boolean } = {}
): { success: boolean; error?: string; path: string } {
  const absolutePath = path.resolve(process.cwd(), outputPath);

  try {
    const content = generateTypeScript(schema, options);

    // Ensure directory exists
    const dir = path.dirname(absolutePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(absolutePath, content, 'utf-8');

    return {
      success: true,
      path: absolutePath,
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to write TypeScript file: ${error instanceof Error ? error.message : String(error)}`,
      path: absolutePath,
    };
  }
}

/**
 * Generate .env.example content from schema
 */
export function generateEnvExample(schema: EnvSchema, options: { comments?: boolean } = {}): string {
  const lines: string[] = [];
  const showComments = options.comments !== false;

  if (showComments) {
    lines.push('# Environment variables for this project');
    lines.push('# Generated by env-guardian');
    lines.push('');
  }

  for (const [name, spec] of Object.entries(schema.variables)) {
    if (showComments && spec.description) {
      lines.push(`# ${spec.description}`);
    }

    if (showComments && spec.enum && spec.enum.length > 0) {
      lines.push(`# Allowed values: ${spec.enum.join(', ')}`);
    }

    if (showComments && !spec.required) {
      lines.push('# Optional');
    }

    // Use default value if available, otherwise empty
    const value = spec.default !== undefined ? String(spec.default) : '';
    lines.push(`${name}=${value}`);

    if (showComments) {
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Write .env.example file
 */
export function writeEnvExample(
  schema: EnvSchema,
  outputPath: string,
  options: { comments?: boolean } = {}
): { success: boolean; error?: string; path: string } {
  const absolutePath = path.resolve(process.cwd(), outputPath);

  try {
    const content = generateEnvExample(schema, options);

    // Ensure directory exists
    const dir = path.dirname(absolutePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(absolutePath, content, 'utf-8');

    return {
      success: true,
      path: absolutePath,
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to write .env.example: ${error instanceof Error ? error.message : String(error)}`,
      path: absolutePath,
    };
  }
}
